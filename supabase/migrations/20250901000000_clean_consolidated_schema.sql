-- Clean consolidated schema migration for League Bets Beta
-- This migration represents the current working state of the database
-- Created to resolve migration conflicts and enable proper branching

-- ============================================================================
-- EXTENSIONS
-- ============================================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS pg_net;
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- ============================================================================
-- ENUMS
-- ============================================================================

-- Create league_type enum
DO $$ BEGIN
    CREATE TYPE public.league_type AS ENUM ('free', 'premium');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- ============================================================================
-- COMPOSITE TYPES
-- ============================================================================

-- Create username_update_result composite type
DO $$ BEGIN
    CREATE TYPE public.username_update_result AS (
        success boolean,
        message text
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- ============================================================================
-- TABLES
-- ============================================================================

-- Create leagues table
CREATE TABLE IF NOT EXISTS public.leagues (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at timestamptz NOT NULL DEFAULT now(),
    name text,
    join_code text UNIQUE,
    type public.league_type NOT NULL DEFAULT 'free'::league_type,
    week integer NOT NULL DEFAULT 1,
    reset_budget text,
    budget integer,
    min_bet numeric DEFAULT 1,
    max_bet numeric,
    league_season integer DEFAULT 1,
    previous_champion text,
    previous_last text,
    CONSTRAINT leagues_league_season_check CHECK (league_season > 0)
);

-- Create profiles table
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid PRIMARY KEY DEFAULT auth.uid(),
    username text NOT NULL UNIQUE,
    weekly_budget numeric DEFAULT '1000'::numeric,
    total_points numeric,
    league_id bigint REFERENCES public.leagues(id) ON DELETE SET NULL,
    role text NOT NULL DEFAULT 'user'::text,
    global_role text DEFAULT 'user'::text,
    last_week_points numeric DEFAULT 0.00,
    CONSTRAINT profiles_role_check CHECK (role = ANY (ARRAY['user'::text, 'admin_league'::text])),
    CONSTRAINT profiles_global_role_check CHECK (global_role = ANY (ARRAY['user'::text, 'superadmin'::text]))
);

-- Create bets table with proper sequence
CREATE SEQUENCE IF NOT EXISTS public.bets_id_seq;
CREATE TABLE IF NOT EXISTS public.bets (
    id bigint PRIMARY KEY DEFAULT nextval('public.bets_id_seq'),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    match_description text,
    bet_selection text,
    stake numeric,
    odds numeric,
    status text,
    payout numeric,
    fixture_id integer,
    bet_type text DEFAULT 'single'::text,
    week text,
    market_bets text
);

-- Create bet_selections table
CREATE TABLE IF NOT EXISTS public.bet_selections (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bet_id bigint NOT NULL REFERENCES public.bets(id) ON DELETE CASCADE,
    fixture_id integer,
    market text,
    selection text,
    odds numeric,
    status text DEFAULT 'pending'::text,
    created_at timestamptz DEFAULT now(),
    match_description text
);

-- Create match_odds_cache table
CREATE TABLE IF NOT EXISTS public.match_odds_cache (
    id smallint PRIMARY KEY DEFAULT '1'::smallint,
    data jsonb NOT NULL DEFAULT '{}'::jsonb,
    last_updated timestamp DEFAULT now()
);

-- Create match_results table
CREATE TABLE IF NOT EXISTS public.match_results (
    fixture_id bigint PRIMARY KEY,
    match_name text NOT NULL,
    home_team text NOT NULL,
    away_team text NOT NULL,
    league_id integer NOT NULL,
    season integer NOT NULL,
    home_goals integer NOT NULL,
    away_goals integer NOT NULL,
    halftime_home integer NOT NULL,
    halftime_away integer NOT NULL,
    outcome text NOT NULL,
    finished_at timestamp NOT NULL,
    match_result text
);

-- Create news table
CREATE TABLE IF NOT EXISTS public.news (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title text NOT NULL,
    content text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    created_by uuid NOT NULL,
    is_active boolean NOT NULL DEFAULT true,
    is_frozen boolean NOT NULL DEFAULT false
);

-- Create weekly_performance table with proper sequence
CREATE SEQUENCE IF NOT EXISTS public.weekly_performance_id_seq;
CREATE TABLE IF NOT EXISTS public.weekly_performance (
    id bigint PRIMARY KEY DEFAULT nextval('public.weekly_performance_id_seq'),
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    start_date timestamptz NOT NULL,
    end_date timestamptz NOT NULL,
    net_profit numeric NOT NULL DEFAULT 0,
    league_id bigint REFERENCES public.leagues(id) ON DELETE SET NULL,
    created_at timestamptz NOT NULL DEFAULT now()
);

-- Create backup tables (for data preservation)
CREATE TABLE IF NOT EXISTS public.backup_bet_selections (
    id bigint,
    bet_id bigint,
    fixture_id integer,
    market text,
    selection text,
    odds numeric,
    status text,
    created_at timestamptz,
    match_description text
);

CREATE TABLE IF NOT EXISTS public.backup_bets (
    id bigint,
    user_id uuid,
    match_description text,
    bet_selection text,
    stake numeric,
    odds numeric,
    status text,
    payout numeric,
    fixture_id integer,
    bet_type text,
    week text
);

CREATE TABLE IF NOT EXISTS public.backup_profiles_points (
    id uuid,
    total_points numeric
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Performance indexes
CREATE INDEX IF NOT EXISTS idx_bets_fixture_id ON public.bets (fixture_id);
CREATE INDEX IF NOT EXISTS idx_bets_user_id ON public.bets (user_id);
CREATE INDEX IF NOT EXISTS idx_bets_status ON public.bets (status);
CREATE INDEX IF NOT EXISTS idx_bet_selections_bet_id ON public.bet_selections (bet_id);
CREATE INDEX IF NOT EXISTS idx_news_created_at ON public.news (created_at DESC);
CREATE INDEX IF NOT EXISTS idx_news_is_active ON public.news (is_active);
CREATE INDEX IF NOT EXISTS idx_weekly_performance_user_id ON public.weekly_performance (user_id);
CREATE INDEX IF NOT EXISTS idx_weekly_performance_dates ON public.weekly_performance (start_date, end_date);
CREATE INDEX IF NOT EXISTS idx_profiles_league_id ON public.profiles (league_id);

-- Unique constraint for single-row cache
CREATE UNIQUE INDEX IF NOT EXISTS match_odds_cache_single_row ON public.match_odds_cache (id);

-- ============================================================================
-- FUNCTIONS
-- ============================================================================

-- Security definer function to get current user's league ID
CREATE OR REPLACE FUNCTION public.get_current_user_league_id()
RETURNS bigint AS $$
  SELECT league_id FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Get current user's role
CREATE OR REPLACE FUNCTION public.get_current_user_role()
RETURNS text AS $$
  SELECT role FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Get current user's global role
CREATE OR REPLACE FUNCTION public.get_current_user_global_role()
RETURNS text AS $$
  SELECT global_role FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Get current user's league role
CREATE OR REPLACE FUNCTION public.get_current_user_league_role()
RETURNS text AS $$
  SELECT role FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Check if user is superadmin
CREATE OR REPLACE FUNCTION public.is_superadmin(user_id uuid DEFAULT auth.uid())
RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = user_id AND global_role = 'superadmin'
  );
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Check if user has admin privileges
CREATE OR REPLACE FUNCTION public.has_admin_privileges(user_id uuid DEFAULT auth.uid())
RETURNS boolean AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = user_id 
    AND (global_role = 'superadmin' OR role = 'admin_league')
  );
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Check username availability
CREATE OR REPLACE FUNCTION public.check_username_availability(username_to_check text)
RETURNS boolean AS $$
  SELECT NOT EXISTS (
    SELECT 1
    FROM public.profiles p
    WHERE p.username = username_to_check
  );
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- Create league and join function
CREATE OR REPLACE FUNCTION public.create_league_and_join(_league_name text, _user_id uuid)
RETURNS void AS $$
DECLARE
  new_league_id bigint;
  code text;
  attempts int := 0;
BEGIN
  -- Only allow the authenticated user to act on themselves
  IF auth.uid() IS NULL OR auth.uid() <> _user_id THEN
    RAISE EXCEPTION 'Forbidden' USING ERRCODE = '42501';
  END IF;

  -- Try generating a unique 8-character alphanumeric (hex) code
  LOOP
    attempts := attempts + 1;
    code := upper(substring(md5(random()::text), 1, 8));
    BEGIN
      INSERT INTO public.leagues (name, join_code)
      VALUES (_league_name, code)
      RETURNING id INTO new_league_id;
      EXIT; -- success
    EXCEPTION WHEN unique_violation THEN
      -- Retry a few times if collision occurs
      IF attempts > 5 THEN
        RAISE;
      END IF;
    END;
  END LOOP;

  -- Assign user to the newly created league
  UPDATE public.profiles
  SET league_id = new_league_id
  WHERE id = _user_id;

  RETURN;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Join league with code function
CREATE OR REPLACE FUNCTION public.join_league_with_code(_join_code text, _user_id uuid)
RETURNS boolean AS $$
DECLARE
  target_league_id bigint;
  joined boolean := false;
BEGIN
  -- Only allow the authenticated user to act on themselves
  IF auth.uid() IS NULL OR auth.uid() <> _user_id THEN
    RAISE EXCEPTION 'Forbidden' USING ERRCODE = '42501';
  END IF;

  -- Find league by join code
  SELECT l.id INTO target_league_id
  FROM public.leagues l
  WHERE l.join_code = _join_code
  LIMIT 1;

  IF target_league_id IS NULL THEN
    RETURN false; -- no league found
  END IF;

  -- Update user's profile to join the league
  UPDATE public.profiles
  SET league_id = target_league_id
  WHERE id = _user_id;

  joined := true;
  RETURN joined;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update league points function
CREATE OR REPLACE FUNCTION public.update_league_points(user_id uuid, points_to_add numeric)
RETURNS void AS $$
BEGIN
  UPDATE public.profiles
  SET total_points = COALESCE(public.profiles.total_points, 0) + COALESCE(points_to_add, 0)
  WHERE id = user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recalculate total points function
CREATE OR REPLACE FUNCTION public.recalc_total_points()
RETURNS void AS $$
BEGIN
  UPDATE public.profiles
  SET total_points = (
    SELECT COALESCE(SUM(payout), 0)
    FROM public.bets
    WHERE user_id = public.profiles.id
      AND status = 'won'
  )
  WHERE id IS NOT NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Reset weekly budgets function
CREATE OR REPLACE FUNCTION public.reset_weekly_budgets()
RETURNS void AS $$
BEGIN
  -- Reset leagues with daily reset
  UPDATE public.profiles p
  SET weekly_budget = l.budget
  FROM public.leagues l
  WHERE p.league_id = l.id
    AND l.reset_budget = 'daily';

  -- Reset leagues with weekly reset only on Tuesdays
  IF EXTRACT(DOW FROM CURRENT_DATE) = 2 THEN  -- 0=Sunday, 1=Monday, 2=Tuesday
    -- Update weekly_budget for users
    UPDATE public.profiles p
    SET weekly_budget = l.budget
    FROM public.leagues l
    WHERE p.league_id = l.id
      AND l.reset_budget = 'weekly';

    -- Increment the week column by 1 for weekly leagues
    UPDATE public.leagues
    SET week = week + 1
    WHERE reset_budget = 'weekly';
  END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update last week points function
CREATE OR REPLACE FUNCTION public.update_last_week_points()
RETURNS void AS $$
BEGIN
    UPDATE profiles p
    SET last_week_points = COALESCE((
        SELECT SUM(b.payout)
        FROM bets b
        JOIN leagues l ON l.id = p.league_id
        WHERE b.user_id = p.id
          AND b.week::integer = l.week::integer
    ), 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Calculate and store weekly performance function
CREATE OR REPLACE FUNCTION public.calculate_and_store_weekly_performance()
RETURNS void AS $$
DECLARE
  v_start_date TIMESTAMP WITH TIME ZONE;
  v_end_date TIMESTAMP WITH TIME ZONE;
  v_user RECORD;
  v_net_profit NUMERIC;
BEGIN
  -- Calculate the date range for the past 7 days
  v_end_date := date_trunc('day', now());
  v_start_date := v_end_date - INTERVAL '7 days';
  
  -- Loop through each user and calculate their performance
  FOR v_user IN 
    SELECT p.id, p.league_id 
    FROM public.profiles p
  LOOP
    -- Calculate net profit for this user over the period
    SELECT 
      COALESCE(SUM(COALESCE(b.payout, 0) - COALESCE(b.stake, 0)), 0)
    INTO v_net_profit
    FROM public.bets b
    WHERE b.user_id = v_user.id
      AND b.status IN ('won', 'lost') -- Only settled bets
      AND b.created_at >= v_start_date
      AND b.created_at < v_end_date;
    
    -- Insert the performance record
    INSERT INTO public.weekly_performance (
      user_id, 
      start_date, 
      end_date, 
      net_profit, 
      league_id
    ) VALUES (
      v_user.id,
      v_start_date,
      v_end_date,
      v_net_profit,
      v_user.league_id
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Place combo bet function
CREATE OR REPLACE FUNCTION public.place_combo_bet(selections jsonb, stake_amount numeric)
RETURNS bigint AS $$
declare
  v_user_id uuid;
  v_bet_id bigint;
  v_total_odds numeric := 1;
  v_sel jsonb;
  v_fixture_id bigint;
  v_market text;
  v_selection text;
  v_odds numeric;
  v_match_description text;
  v_now timestamptz := now();
  v_budget numeric;
begin
  -- Current user
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'not_authenticated';
  end if;

  -- Budget check
  select weekly_budget into v_budget
  from profiles
  where id = v_user_id
  for update;

  if v_budget is null or v_budget < stake_amount then
    raise exception 'insufficient_budget';
  end if;

  -- Avoid duplicate matches in combo
  if exists (
    select 1
    from (
      select (e->>'fixture_id') as f
      from jsonb_array_elements(selections) e
      where e ? 'fixture_id'
    ) t
    where f is not null
    group by f
    having count(*) > 1
  ) then
    raise exception 'duplicate_fixture_in_combo';
  end if;

  -- Create combo bet
  insert into bets (user_id, stake, odds, status, payout, bet_type)
  values (v_user_id, stake_amount, 1, 'pending', 0, 'combo')
  returning id into v_bet_id;

  -- Insert selections (includes match_description)
  for v_sel in select * from jsonb_array_elements(selections)
  loop
    v_fixture_id := nullif((v_sel->>'fixture_id')::bigint, 0);
    v_market := v_sel->>'market';
    v_selection := v_sel->>'selection';
    v_odds := (v_sel->>'odds')::numeric;
    v_match_description := v_sel->>'match_description';

    if v_odds is null then
      raise exception 'selection_missing_odds';
    end if;

    v_total_odds := v_total_odds * v_odds;

    insert into bet_selections (
      bet_id, fixture_id, market, selection, odds, status, match_description, created_at
    ) values (
      v_bet_id, v_fixture_id, v_market, v_selection, v_odds, 'pending', v_match_description, v_now
    );
  end loop;

  -- Update totals in bets
  update bets
  set odds = v_total_odds,
      payout = round(stake_amount * v_total_odds, 2)
  where id = v_bet_id;

  -- Deduct budget
  update profiles
  set weekly_budget = weekly_budget - stake_amount
  where id = v_user_id;

  return v_bet_id;
end;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cancel bet function
CREATE OR REPLACE FUNCTION public.cancel_bet(bet_id_param bigint)
RETURNS jsonb AS $$
DECLARE
  v_bet RECORD;
  v_profile RECORD;
  v_earliest_kickoff timestamp with time zone;
  v_current_time timestamp with time zone := now();
  v_cutoff_time timestamp with time zone;
  v_fixture_id integer;
  v_kickoff_time timestamp with time zone;
  v_match_result RECORD;
BEGIN
  -- Get the bet details
  SELECT * INTO v_bet
  FROM bets
  WHERE id = bet_id_param AND user_id = auth.uid();

  -- Check if bet exists and belongs to user
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Bet not found or you do not have permission to cancel it';
  END IF;

  -- Check if bet is still pending
  IF v_bet.status != 'pending' THEN
    RAISE EXCEPTION 'Only pending bets can be cancelled';
  END IF;

  -- Handle different bet types
  IF v_bet.bet_type = 'single' THEN
    -- Single bet logic
    IF v_bet.fixture_id IS NULL THEN
      RAISE EXCEPTION 'This bet is not linked to a fixture';
    END IF;

    -- Look for fixture kickoff time in match_results table
    SELECT kickoff_time INTO v_kickoff_time
    FROM match_results
    WHERE fixture_id = v_bet.fixture_id;

    IF v_kickoff_time IS NULL THEN
      RAISE EXCEPTION 'Kickoff time not found for this fixture';
    END IF;

    v_earliest_kickoff := v_kickoff_time;

  ELSIF v_bet.bet_type = 'combo' THEN
    -- Combo bet logic
    v_earliest_kickoff := NULL;
    
    -- Get all fixture IDs from bet selections and find earliest kickoff
    FOR v_fixture_id IN 
      SELECT DISTINCT fixture_id 
      FROM bet_selections 
      WHERE bet_id = bet_id_param AND fixture_id IS NOT NULL
    LOOP
      -- Look for fixture kickoff time in match_results table
      SELECT kickoff_time INTO v_kickoff_time
      FROM match_results
      WHERE fixture_id = v_fixture_id;

      IF v_kickoff_time IS NOT NULL THEN
        -- Track earliest kickoff time
        IF v_earliest_kickoff IS NULL OR v_kickoff_time < v_earliest_kickoff THEN
          v_earliest_kickoff := v_kickoff_time;
        END IF;
      END IF;
    END LOOP;

    -- Check if we found any valid kickoff times
    IF v_earliest_kickoff IS NULL THEN
      RAISE EXCEPTION 'No valid fixture data found for this combo bet';
    END IF;

  ELSE
    RAISE EXCEPTION 'Unknown bet type: %', v_bet.bet_type;
  END IF;

  -- Calculate cutoff time (15 minutes before earliest kickoff)
  v_cutoff_time := v_earliest_kickoff - INTERVAL '15 minutes';

  -- Check if current time is past the cutoff
  IF v_current_time > v_cutoff_time THEN
    RAISE EXCEPTION 'Cannot cancel bet - less than 15 minutes until kickoff';
  END IF;

  -- Get user profile
  SELECT * INTO v_profile
  FROM profiles
  WHERE id = auth.uid();

  IF NOT FOUND THEN
    RAISE EXCEPTION 'User profile not found';
  END IF;

  -- Refund the stake to weekly budget
  UPDATE profiles
  SET weekly_budget = weekly_budget + v_bet.stake
  WHERE id = auth.uid();

  -- Update bet status to cancelled and set payout to 0
  UPDATE bets 
  SET status = 'cancelled', 
      payout = 0
  WHERE id = bet_id_param;

  -- Update bet_selections status to cancelled
  UPDATE bet_selections 
  SET status = 'cancelled'
  WHERE bet_id = bet_id_param;

  -- Return success response
  RETURN jsonb_build_object(
    'success', true,
    'message', 'Bet cancelled successfully',
    'refunded_amount', v_bet.stake,
    'earliest_kickoff', v_earliest_kickoff,
    'cutoff_time', v_cutoff_time
  );

EXCEPTION
  WHEN OTHERS THEN
    -- Return error response
    RETURN jsonb_build_object(
      'success', false,
      'error', SQLERRM
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update combo bet status function
CREATE OR REPLACE FUNCTION public.update_combo_bet_status(bet_id_to_check bigint)
RETURNS void AS $$
DECLARE
  v_bet           public.bets%ROWTYPE;
  v_pending_cnt   int;
  v_lost_cnt      int;
  v_won_cnt       int;
  v_combined_odds numeric;
  v_payout        numeric;
BEGIN
  -- Load parent bet
  SELECT * INTO v_bet
  FROM public.bets
  WHERE id = bet_id_to_check
    AND bet_type = 'combo';

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Count leg statuses
  SELECT
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END),
    SUM(CASE WHEN status = 'lost'    THEN 1 ELSE 0 END),
    SUM(CASE WHEN status = 'won'     THEN 1 ELSE 0 END)
  INTO v_pending_cnt, v_lost_cnt, v_won_cnt
  FROM public.bet_selections
  WHERE bet_id = v_bet.id;

  -- If any leg still pending, keep parent pending
  IF v_pending_cnt > 0 THEN
    RETURN;
  END IF;

  -- If any leg lost → whole combo lost
  IF v_lost_cnt > 0 THEN
    UPDATE public.bets
    SET status = 'lost',
        payout = 0,
        odds   = NULL
    WHERE id = v_bet.id;
    RETURN;
  END IF;

  -- All legs settled and none lost → combo won
  -- Combined odds = product of leg odds
  SELECT COALESCE(EXP(SUM(LN(NULLIF(odds, 0)))), 0)
  INTO v_combined_odds
  FROM public.bet_selections
  WHERE bet_id = v_bet.id;

  v_payout := COALESCE(v_bet.stake, 0) * COALESCE(v_combined_odds, 0);

  UPDATE public.bets
  SET status = 'won',
      payout = v_payout,
      odds   = v_combined_odds
  WHERE id = v_bet.id;

  -- Credit points equal to payout
  PERFORM public.update_league_points(v_bet.user_id, v_payout);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Get stuck combo bets function
CREATE OR REPLACE FUNCTION public.get_stuck_combo_bets()
RETURNS TABLE(id bigint) AS $$
BEGIN
  RETURN QUERY
  SELECT b.id
  FROM public.bets b
  WHERE b.bet_type = 'combo' AND b.status = 'pending'
  AND NOT EXISTS (
    SELECT 1
    FROM public.bet_selections bs
    WHERE bs.bet_id = b.id AND bs.status = 'pending'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update username function with composite return type
CREATE OR REPLACE FUNCTION public.update_username(new_username text)
RETURNS public.username_update_result AS $$
DECLARE
  current_user_id uuid;
  username_exists boolean;
  result public.username_update_result;
BEGIN
  -- Check if user is authenticated
  current_user_id := auth.uid();
  IF current_user_id IS NULL THEN
    result.success := false;
    result.message := 'User not authenticated';
    RETURN result;
  END IF;

  -- Validate username (basic checks)
  IF new_username IS NULL OR trim(new_username) = '' THEN
    result.success := false;
    result.message := 'Username cannot be empty';
    RETURN result;
  END IF;

  -- Check username length
  IF length(trim(new_username)) < 3 THEN
    result.success := false;
    result.message := 'Username must be at least 3 characters long';
    RETURN result;
  END IF;

  IF length(trim(new_username)) > 15 THEN
    result.success := false;
    result.message := 'Username must be 15 characters or less';
    RETURN result;
  END IF;

  -- Check if username already exists (case-insensitive)
  SELECT EXISTS (
    SELECT 1 
    FROM public.profiles 
    WHERE lower(username) = lower(trim(new_username))
      AND id != current_user_id
  ) INTO username_exists;

  IF username_exists THEN
    result.success := false;
    result.message := 'Username is already taken';
    RETURN result;
  END IF;

  -- Update the username
  UPDATE public.profiles
  SET username = trim(new_username)
  WHERE id = current_user_id;

  -- Check if update was successful
  IF NOT FOUND THEN
    result.success := false;
    result.message := 'User profile not found';
    RETURN result;
  END IF;

  result.success := true;
  result.message := 'Username updated successfully';
  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Cron process results function
CREATE OR REPLACE FUNCTION public.cron_process_results()
RETURNS void AS $$
DECLARE
  service_key_value text;
BEGIN
  -- Securely retrieve the key from the Supabase Vault
  SELECT decrypted_secret INTO service_key_value 
  FROM vault.decrypted_secrets 
  WHERE name = 'SUPABASE_SERVICE_ROLE_KEY';

  -- If the key is not found, raise an error
  IF service_key_value IS NULL THEN
    RAISE EXCEPTION 'Secret "SUPABASE_SERVICE_ROLE_KEY" not found in Supabase Vault.';
  END IF;

  -- Perform the HTTP POST request using the retrieved key
  PERFORM net.http_post(
    url := 'https://jhsjszflscbpcfzuurwq.supabase.co/functions/v1/secure-run-process-matchday-results',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || service_key_value
    ),
    body := '{}'::jsonb
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Schedule one time HTTP call function (corrected signature)
CREATE OR REPLACE FUNCTION public.schedule_one_time_http_call(
  job_name text,
  schedule text,
  url text,
  auth_header text,
  body text
)
RETURNS text AS $$
DECLARE
  job_id TEXT;
BEGIN
  -- Use pg_cron to schedule a one-time HTTP call
  SELECT cron.schedule(
    job_name,
    schedule,
    format(
      'SELECT net.http_post(url := %L, headers := %L, body := %L);',
      url,
      format('{"Authorization": "%s", "Content-Type": "application/json"}', auth_header)::jsonb,
      body::jsonb
    )
  ) INTO job_id;
  
  RETURN job_id::TEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- TRIGGER FUNCTIONS
-- ============================================================================

-- Trigger function to set bet week from league
CREATE OR REPLACE FUNCTION public.set_bet_week_from_league()
RETURNS trigger AS $$
DECLARE
    user_league_id bigint;
    league_week integer;
BEGIN
    -- Get the league of the user who made the bet
    SELECT league_id INTO user_league_id
    FROM profiles
    WHERE id = NEW.user_id;

    -- Get the current week of that league
    SELECT week INTO league_week
    FROM leagues
    WHERE id = user_league_id;

    -- Update the bet with the league's week
    NEW.week := league_week::text;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger function to set match description for combo bets
CREATE OR REPLACE FUNCTION public.set_match_description()
RETURNS trigger AS $$
DECLARE
  description text;
  b_type text;
BEGIN
  -- Get the bet type
  SELECT bet_type INTO b_type FROM bets WHERE id = NEW.bet_id;

  -- Only act if it's a combo
  IF b_type = 'combo' THEN

    -- Try to find in match_odds_cache
    SELECT CONCAT(
             value->'teams'->'home'->>'name', ' vs ',
             value->'teams'->'away'->>'name'
           )
    INTO description
    FROM match_odds_cache moc,
         jsonb_array_elements(moc.data->'response') AS value
    WHERE (value->'fixture'->>'id')::int = NEW.fixture_id
    LIMIT 1;

    -- If not found in JSON, use the description from bets
    IF description IS NULL THEN
      SELECT match_description
      INTO description
      FROM bets
      WHERE id = NEW.bet_id;
    END IF;

    -- Assign the value
    NEW.match_description := description;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger function to update result text
CREATE OR REPLACE FUNCTION public.update_result_text()
RETURNS trigger AS $$
BEGIN
    NEW.match_result := NEW.home_goals || ' - ' || NEW.away_goals;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger function for auth handler
CREATE OR REPLACE FUNCTION public.trigger_auth_handler_on_new_user()
RETURNS trigger AS $$
BEGIN
  -- Perform a POST request to the auth-handler Edge Function
  PERFORM net.http_post(
    url := 'https://jhsjszflscbpcfzuurwq.supabase.co/functions/v1/auth-handler',
    body := jsonb_build_object(
      'type', 'INSERT',
      'table', 'users',
      'schema', 'auth',
      'record', row_to_json(NEW)
    ),
    headers := '{"Content-Type":"application/json"}'::jsonb
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Legacy handle_new_user function (for backwards compatibility)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, username)
  VALUES (NEW.id, 'user_' || substr(NEW.id::text, 1, 8))
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Drop existing triggers to avoid conflicts
DROP TRIGGER IF EXISTS trigger_set_bet_week ON public.bets;
DROP TRIGGER IF EXISTS trigger_set_match_description ON public.bet_selections;
DROP TRIGGER IF EXISTS trigger_update_result_text ON public.match_results;
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create triggers
CREATE TRIGGER trigger_set_bet_week
  BEFORE INSERT ON public.bets
  FOR EACH ROW
  EXECUTE FUNCTION public.set_bet_week_from_league();

CREATE TRIGGER trigger_set_match_description
  BEFORE INSERT ON public.bet_selections
  FOR EACH ROW
  EXECUTE FUNCTION public.set_match_description();

CREATE TRIGGER trigger_update_result_text
  BEFORE INSERT OR UPDATE ON public.match_results
  FOR EACH ROW
  EXECUTE FUNCTION public.update_result_text();

-- Auth trigger (calls Edge Function for profile creation)
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.trigger_auth_handler_on_new_user();

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE public.leagues ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bet_selections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.match_odds_cache ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.match_results ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.news ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.weekly_performance ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.backup_bet_selections ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.backup_bets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.backup_profiles_points ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- POLICIES
-- ============================================================================

-- Drop all existing policies to avoid conflicts
DROP POLICY IF EXISTS "Users can only view their own league" ON public.leagues;
DROP POLICY IF EXISTS "Users can create leagues" ON public.leagues;
DROP POLICY IF EXISTS "Users can update their own league" ON public.leagues;
DROP POLICY IF EXISTS "Users can view own profile or league members" ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can delete their own profile" ON public.profiles;
DROP POLICY IF EXISTS "Users can view their own bets" ON public.bets;
DROP POLICY IF EXISTS "League members can view league bets" ON public.bets;
DROP POLICY IF EXISTS "Users can create their own bets" ON public.bets;
DROP POLICY IF EXISTS "Users can update their own bets" ON public.bets;
DROP POLICY IF EXISTS "Users can delete their own bets" ON public.bets;
DROP POLICY IF EXISTS "Users can view their own bet selections" ON public.bet_selections;
DROP POLICY IF EXISTS "League members can view league bet selections" ON public.bet_selections;
DROP POLICY IF EXISTS "Users can create their own bet selections" ON public.bet_selections;
DROP POLICY IF EXISTS "Users can update their own bet selections" ON public.bet_selections;
DROP POLICY IF EXISTS "Users can delete their own bet selections" ON public.bet_selections;
DROP POLICY IF EXISTS "Public can read odds cache" ON public.match_odds_cache;
DROP POLICY IF EXISTS "Service role can manage odds cache" ON public.match_odds_cache;
DROP POLICY IF EXISTS "Users can view match results" ON public.match_results;
DROP POLICY IF EXISTS "Anyone can view active news" ON public.news;
DROP POLICY IF EXISTS "Superadmins can manage all news" ON public.news;
DROP POLICY IF EXISTS "Admins can manage all news" ON public.news;
DROP POLICY IF EXISTS "Users can view their own performance or league members" ON public.weekly_performance;
DROP POLICY IF EXISTS "Service role can manage all performance records" ON public.weekly_performance;
DROP POLICY IF EXISTS "Users can view their own backup bet selections" ON public.backup_bet_selections;
DROP POLICY IF EXISTS "Service role can manage backup bet selections" ON public.backup_bet_selections;
DROP POLICY IF EXISTS "Superadmins can view all backup bet selections" ON public.backup_bet_selections;
DROP POLICY IF EXISTS "Users can view their own backup bets" ON public.backup_bets;
DROP POLICY IF EXISTS "Service role can manage backup bets" ON public.backup_bets;
DROP POLICY IF EXISTS "Superadmins can view all backup bets" ON public.backup_bets;
DROP POLICY IF EXISTS "Users can view their own backup profile points" ON public.backup_profiles_points;
DROP POLICY IF EXISTS "Service role can manage backup profile points" ON public.backup_profiles_points;
DROP POLICY IF EXISTS "Superadmins can view all backup profile points" ON public.backup_profiles_points;

-- Leagues policies
CREATE POLICY "Users can only view their own league" 
ON public.leagues 
FOR SELECT 
TO public
USING (id = (SELECT profiles.league_id FROM profiles WHERE profiles.id = auth.uid()));

CREATE POLICY "Users can create leagues" 
ON public.leagues 
FOR INSERT 
TO public
WITH CHECK (true);

CREATE POLICY "Users can update their own league" 
ON public.leagues 
FOR UPDATE 
TO public
USING (id = (SELECT profiles.league_id FROM profiles WHERE profiles.id = auth.uid()))
WITH CHECK (id = (SELECT profiles.league_id FROM profiles WHERE profiles.id = auth.uid()));

-- Profiles policies
CREATE POLICY "Users can view own profile or league members" 
ON public.profiles 
FOR SELECT 
TO public
USING ((id = auth.uid()) OR ((league_id IS NOT NULL) AND (league_id = get_current_user_league_id())));

CREATE POLICY "Users can insert their own profile" 
ON public.profiles 
FOR INSERT 
TO authenticated
WITH CHECK (id = auth.uid());

CREATE POLICY "Users can update their own profile" 
ON public.profiles 
FOR UPDATE 
TO authenticated
USING (id = auth.uid())
WITH CHECK (id = auth.uid());

CREATE POLICY "Users can delete their own profile" 
ON public.profiles 
FOR DELETE 
TO authenticated
USING (id = auth.uid());

-- Bets policies
CREATE POLICY "Users can view their own bets" 
ON public.bets 
FOR SELECT 
TO public
USING (user_id = auth.uid());

CREATE POLICY "League members can view league bets" 
ON public.bets 
FOR SELECT 
TO public
USING ((EXISTS (SELECT 1 FROM profiles p WHERE p.id = bets.user_id AND p.league_id IS NOT NULL AND p.league_id = get_current_user_league_id())) AND (status <> 'pending'::text));

CREATE POLICY "Users can create their own bets" 
ON public.bets 
FOR INSERT 
TO authenticated
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own bets" 
ON public.bets 
FOR UPDATE 
TO authenticated
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can delete their own bets" 
ON public.bets 
FOR DELETE 
TO authenticated
USING (user_id = auth.uid());

-- Bet selections policies
CREATE POLICY "Users can view their own bet selections" 
ON public.bet_selections 
FOR SELECT 
TO public
USING (bet_id IN (SELECT b.id FROM bets b WHERE b.user_id = auth.uid()));

CREATE POLICY "League members can view league bet selections" 
ON public.bet_selections 
FOR SELECT 
TO public
USING (EXISTS (SELECT 1 FROM (bets b JOIN profiles p ON p.id = b.user_id) WHERE b.id = bet_selections.bet_id AND p.league_id IS NOT NULL AND p.league_id = get_current_user_league_id() AND bet_selections.status <> 'pending'::text));

CREATE POLICY "Users can create their own bet selections" 
ON public.bet_selections 
FOR INSERT 
TO public
WITH CHECK (bet_id IN (SELECT bets.id FROM bets WHERE bets.user_id = auth.uid()));

CREATE POLICY "Users can update their own bet selections" 
ON public.bet_selections 
FOR UPDATE 
TO public
USING (bet_id IN (SELECT bets.id FROM bets WHERE bets.user_id = auth.uid()));

CREATE POLICY "Users can delete their own bet selections" 
ON public.bet_selections 
FOR DELETE 
TO public
USING (bet_id IN (SELECT bets.id FROM bets WHERE bets.user_id = auth.uid()));

-- Match odds cache policies
CREATE POLICY "Public can read odds cache" 
ON public.match_odds_cache 
FOR SELECT 
TO anon, authenticated
USING (true);

CREATE POLICY "Service role can manage odds cache" 
ON public.match_odds_cache 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

-- Match results policies
CREATE POLICY "Users can view match results" 
ON public.match_results 
FOR SELECT 
TO authenticated
USING (true);

-- News policies
CREATE POLICY "Anyone can view active news" 
ON public.news 
FOR SELECT 
TO public
USING (is_active = true);

CREATE POLICY "Superadmins can manage all news" 
ON public.news 
FOR ALL 
TO public
USING (is_superadmin());

CREATE POLICY "Admins can manage all news" 
ON public.news 
FOR ALL 
TO public
USING (has_admin_privileges());

-- Weekly performance policies
CREATE POLICY "Users can view their own performance or league members" 
ON public.weekly_performance 
FOR SELECT 
TO public
USING ((user_id = auth.uid()) OR ((league_id IS NOT NULL) AND (league_id = get_current_user_league_id())));

CREATE POLICY "Service role can manage all performance records" 
ON public.weekly_performance 
FOR ALL 
TO public
USING (true)
WITH CHECK (true);

-- Backup tables policies
CREATE POLICY "Users can view their own backup bet selections" 
ON public.backup_bet_selections 
FOR SELECT 
TO authenticated
USING (bet_id IN (SELECT b.id FROM backup_bets b WHERE b.user_id = auth.uid()));

CREATE POLICY "Service role can manage backup bet selections" 
ON public.backup_bet_selections 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

CREATE POLICY "Superadmins can view all backup bet selections" 
ON public.backup_bet_selections 
FOR SELECT 
TO authenticated
USING (is_superadmin());

CREATE POLICY "Users can view their own backup bets" 
ON public.backup_bets 
FOR SELECT 
TO authenticated
USING (user_id = auth.uid());

CREATE POLICY "Service role can manage backup bets" 
ON public.backup_bets 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

CREATE POLICY "Superadmins can view all backup bets" 
ON public.backup_bets 
FOR SELECT 
TO authenticated
USING (is_superadmin());

CREATE POLICY "Users can view their own backup profile points" 
ON public.backup_profiles_points 
FOR SELECT 
TO authenticated
USING (id = auth.uid());

CREATE POLICY "Service role can manage backup profile points" 
ON public.backup_profiles_points 
FOR ALL 
TO service_role
USING (true)
WITH CHECK (true);

CREATE POLICY "Superadmins can view all backup profile points" 
ON public.backup_profiles_points 
FOR SELECT 
TO authenticated
USING (is_superadmin());

-- ============================================================================
-- INITIAL DATA AND PERMISSIONS
-- ============================================================================

-- Insert initial data into match_odds_cache if it doesn't exist
INSERT INTO public.match_odds_cache (id, data) 
VALUES (1, '{}'::jsonb) 
ON CONFLICT (id) DO NOTHING;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO anon, authenticated, service_role;

-- Grant specific permissions for auth trigger
GRANT EXECUTE ON FUNCTION public.trigger_auth_handler_on_new_user() TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_auth_admin;